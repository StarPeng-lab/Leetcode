增删改查
 * add(E),remove(E),set(int,E),get(int)
 * add(int,E),remove(int)
其他方法
 * 构造方法：ArrayList(),ArrayList(int)
 * size()
 * isEmpty()
 * contains(E)
 * indexOf(E)
 * clear()
 * toString()
 * 越界检查：rangeCheck(),rangeCheckForAdd()
 * 动态扩容：ensureCapacity(int) -- 添加元素时检查是否需要扩容
 * 动态数组缩容： -- 删除元素时检查是否需要缩容
 * 复杂度震荡：如果扩容倍数和缩容时机，设计不恰当，则有可能导致复杂度震荡（即之前复杂度低，在扩容缩容时一直维持在复杂度高的地方）
   * 比如，扩容倍数为2倍，缩容时机设置为：当【size <= elements.length/2 && elements.length/2 > DEFAULT_CAPACITY】时，即空闲容量>=数组总容量时，缩容
     那么当数组总容量为30，默认容量为10，所用容量为15时，数组会进行缩容，此时数组总容量变为15；
         此时添加一个元素，由于数组所用容量占满了数组总容量，因此进行扩容，此时数组总容量变为30；
         当再删除这个元素时，又会进行缩容，此时添加、删除元素的这一刻操作，复杂度由原来的O(1)变为O(n)，造成复杂度震荡；
         因为缩容后，再添加元素时，没有多余空间，需要扩容，一扩容就又满足了缩容的条件，因此不断扩容缩容，复杂度震荡；
   * 注意：扩容倍数*缩容因子=1时，容易造成复杂度震荡（当size=elements.length/缩容因子的地方）

泛型E

对象数组
 * 对象的类中，若重写equals()，则建议使用instenceof判断类型，再强转；
 * 因为如果ArrayList<Object>，即存储着的元素类型为Object，那么不能随意强转类型进行比较，应先判断类型是否是同一类型或其子类型，再强转比较

对于null值的处理
 * 见indexOf(E)方法，建议可以写null值
 * remove(E)方法中，其实可以简化书写，内部引用indexOf(E)找到index，再用fastRemove(int index)来删除元素
 （数组无需区分是否是第一个或最后一个元素，这是在链表中区分的）


复杂度：访问数组元素的复杂度，与下标无关，即访问第一个元素与访问中间元素、最后一个元素，耗时相同
      因为编译器是用公式【index*数据类型所占字节大小+数组首地址】进行查找elements[index]；O(1)
      get(int),set(int,E)：O(1)
      add(int,E),remove(E): 最好情况复杂度：O(1)
                            最坏情况复杂度：O(n)
                            平均情况复杂度: O(n)

动态数组特点：随机访问速度非常快 - 查找快（底层是通过元素下标以及数组首地址找到下标元素）；
           增删慢

动态数组优化：以后可以利用index与size/2进行比较，来确定从头开始查找或从尾查找；
      元素可以不移动，而是改变元素下标





