AVLTree，继承自BST：
 * 重新定义AVLTree自己的【构造方法】
 * 重写【afterAdd方法】，用来解决添加导致的平衡；
    # 【更新高度】
    # 【恢复平衡】
 * 重新定义【静态内部类】，继承自 二叉树 的静态内部类TreeNode，新增height成员变量，用来记录平衡因子（|左子树高度-右子树高度| <= 1，即值为：-1,0,1，都为平衡状态）；
   重写【createNode方法】，供AVL树创建自己的节点，带有height成员变量的节点；
   二叉树的TreeNode静态内部类，不直接添加height的原因是，二叉树是通用的，不会因为AVL树需要平衡因子而加上height

【恢复平衡】：
1、添加 导致的失衡
 * 最坏情况：可能导致所有祖先节点都失衡
 * 注意：父节点、非祖父节点，都不可能失衡
 * 修复方式一：找所有失衡节点中高度最低的那个祖先节点，并修复，这样整棵树的高度自然会恢复平衡；因为失衡就是由下往上导致的，是在添加了节点后导致的失衡，把源头修复即可。
   # 找到三个节点
     g: 高度最低的那个不平衡节点
     p: g的左右子节点中高度最高的节点
     n: p的左右子节点中高度最高的节点
   # 判断旋转方向
     单旋：LL（右旋）：node在node的祖父节点的左侧（g.left = p; p.left = n;），这个祖父节点即是g，用tallerNode方法找到p和n，对p进行右旋操作
          RR（左旋）：node在node的祖父节点的右侧（g.right = p; p.right = n;），这个祖父节点即是g，用tallerNode方法找到p和n，对p进行左旋操作
     双旋：LR：g.left = p; p.right = n; 先将p左旋，再将g右旋
          RL：g.right = p; p.left = n; 先将p右旋，再将g左旋
 * 修复方式二：中序遍历子树，按顺序编号a,b,c,d,e,f,g，会发现无论是单旋还是双旋，旋转后得到的子树中序遍历后是一样的，因此我们只需要确定a~g的节点关系即可

2、删除 导致的失衡
 * 注意：只可能导致 被删除节点的父节点 失衡；（祖父节点不会被影响，因为父节点虽然平衡因子失衡了，但父节点的高度不变--->因为如果是由于删除节点而导致父节点失衡了，那么说明删除的是左右子树中短的那棵子树的节点）
        除父节点以外的其他节点，都不可能失衡；（但是画图可知，删除节点后，将失衡节点调整平衡后，失衡节点的祖父节点可能在被调整后，高度变化，导致祖父节点也开始失衡）


时间复杂度：二叉搜索树的时间复杂度与树的高度有关
 * 添加：可能会导致所有的【祖父节点】失衡（最多logn个节点失衡）；
        只要让高度最低的失衡节点恢复平衡，整棵树即可恢复平衡【仅需O(1)次调整】 --> 从添加第一个节点开始，就在关注失衡问题，因此只要调节好高度最低的失衡节点即可
 * 删除：可能会导致【父节点】/【祖先节点】失衡（只有1个节点会失衡），其他节点都不可能失衡；
        让父节点恢复平衡后，可能导致更高层的祖先节点失衡【最多需要O(logn)次调整，因为高度维持在logn级别】
 * 平均时间复杂度：搜索：O(logn)
                添加：O(logn)，仅需O(1)次的旋转操作
                删除：O(logn)，最多需要O(logn)次的旋转操作

练习：110、平衡二叉树
