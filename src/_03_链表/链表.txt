动态数组，缺点：可能造成内存空间的大量浪费，扩容后多出的空间不一定能用上，不能用多少就申请多少内存，开辟回收内存次数少
            （由于内存空间连续，因此每次都是申请一片连续的空间）；
   * 查改快、增删慢
链表：链式存储的线性表，依赖指针实现；
     所有元素的内存空间不一定连续，用多少就申请多少内存，用的时候就申请，因此更节约内存，开辟回收内存次数多；
   * 查改慢、增删快(做增删操作的那一刻快)
   * get(int) , set(int,E) , add(int,E) , remove(int) -- 最好：O(1)
                                                         最坏：O(n)
                                                         平均：O(n)
     add(E) -- 最好：O(1) -- 添加到末尾
            -- 最坏：O(n) -- 添加之前需要扩容
            -- 平均：O(1) -- 1+1+1+1...+n -- O(n)
            -- 均摊复杂度：O(1) -- 经过连续的、多次复杂度较低的情况后，出现个别复杂度高的情况，这时将高的均摊至低的
            （一般均摊复杂度就是最好复杂度）
静态链表：通过数组模拟链表；
        数组的每个元素存放两个数据：值、下个元素的索引；
        数组0位置，存放着头结点的信息
       实现：C语言中的结构体；或者用两个数组，一个存放索引关系，一个存放值



单向链表在删除时，注意边界 0 ；在添加时，注意边界 0 ；
单向循环链表在删除时，注意边界 0 ，以及删除的是唯一元素的情况 ；在添加时，注意边界 0 ，以及添加的是第一个元素的情况 ；
双向链表在删除时，注意边界 0 ， size-1 ；在添加时，注意index==size
双向循环链表在删除时，注意边界 0 ， size-1，以及删除的是唯一元素的情况 ； 在添加时，注意index==size

LinkedList底层用了双向链表；
链表有：单向链表、双向链表、单向循环链表、双向循环链表

练习：237、删除链表中的节点
     203、移除链表元素
     83、删除排序链表中的重复元素
     剑指Offer18、删除链表的节点

     876、链表的中间结点

     206、反转链表

     141、环形链表

     约瑟夫问题：n个人围成一圈，从第一个开始报数，第m个将被淘汰，最后剩下一个，其余人都将被淘汰
      * 利用单向循环链表/双向循环链表来解决
      * 增设1个成员变量，current，用于指向某个节点
      * 增设3个方法，void reset()：让current指向头结点first
                  E next()：让current往后走一步，即current=current.next;
                  E remove()：删除current指向的节点，删除成功后让current指向下一个节点
