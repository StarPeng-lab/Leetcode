树：
 * 节点、根节点、叶子节点、父节点、子节点、兄弟节点；空树、子树、左子树、右子树；有序树、无序树
 * 树的层数：叶子节点可以当作第0层，也可以当作第1层
 * 节点的度：节点的子树个数
 * 树的度：所有节点的度的最大值
 * 节点的深度：当前节点到根节点经过路径的节点个数
 * 树的深度：所有节点的深度的最大值
 * 节点的高度：当前节点到最远叶子节点经过路径的节点个数
 * 树的高度：所有节点的高度的最大值
 * 一般，树的深度=树的高度
有序树：
 * 树中任意节点的子节点之间有顺序关系
无序树：
 *  树中任意节点的子节点之间没有顺序关系，也称为自由树
森林：
 * 由 m(m>0) 棵互不相交的树组成的集合

二叉树，Binary Tree：
 * 二叉树的节点度最大为2
 * 二叉树的左右子树是有顺序的，即二叉树是有序树
 * 假设二叉树的高度为h，总节点数为n
  * 二叉树第 i 层的节点数为：2^(i-1)，i>=1
  * 二叉树的总节点数n为：n = 2^h -1，h>=1
  * 若任意一棵非空二叉树中，度为0的节点数为n0，度为1的节点数为n1，度为2的节点数为n2，那么：n0 = n2 + 1
   # n = n0 + n1 + n2 , 二叉树的边 = n - 1 = n1 + 2*n2 ； （n-1指所有节点头上都有一条边，除了根节点）
   # 因此，n0 + n1 + n2 - 1 = n1 + 2*n2；因此，n0 - 1 = n2，即 n0 = n2 + 1

1、真二叉树，Proper Binary Tree，国外称作完满二叉树（Full Binary Tree）
 * 所有节点的度要么为0，要么为2

2、满二叉树，Full Binary Tree，国外称作完美二叉树（Perfect Binary Tree）
 * 叶子节点只能在最后一层（即）
 * 满二叉树一定是真二叉树，真二叉树不一定是满二叉树
 * 同样高度的二叉树中，满二叉树的叶子节点数最多，总节点树最多
 * 假设满二叉树的高度为 h(h>=1)，那么
  # 叶子节点数量：2^(h-1)
  # 总节点数量：n = 2^h - 1 = 2^0 + 2^1 + 2^2 + ... + 2^(h-2) + 2^(h-1)
  # 高度：h = log2 (n+1)

3、完全二叉树，Complete Binary Tree
 * 对节点按从上到下、从左到右的顺序进行编号，其所有编号都能与相同高度的满二叉树中的编号对应
 * 叶子节点只会出现在最后2层，最后1层的叶子节点都靠左对齐
 * 除去完全二叉树的最后一层，就是满二叉树
 * 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树
性质：
 * 度为1的节点只有左子树
 * 度为1的节点要么是1个，要么是0个
 * 同样节点数量的二叉树，完全二叉树的高度最小
 * 假设完全二叉树的高度为h，
  # 完全二叉树的最小节点数：n = 2^(h-1) = 2^0 + 2^1 + 2^2 + ... + 2^(h-2) + 1 ，最后一层只有一个节点
  # 完全二叉树的最大节点数：n = 2^h - 1 = 2^0 + 2^1 + 2^2 + ... + 2^(h-2) + 2^(h-1) ，最后一层有2^(h-1)个节点
  # 根据节点总数n，求树的高度h
    2^(h-1) <= n <= 2^h - 1
    2^(h-1) <= n < 2^h
    h-1 <= log2 n < h，根据这个取值范围，可得：h = floor(log2 n) + 1
 * 一棵有n个节点的完全二叉树，从上到下，从左到右，对节点从 1 开始编号，那么对任意第i个节点：
  # 如果 i = 1，它是根节点
  # 如果 i > 1，它的父节点编号为 floor( i/2 )
  # 如果 2*i <= n，它的左子节点编号为 2*i
  # 如果 2*i > n，它无左子节点
  # 如果 2*i + 1 <= n，它的右子节点编号为 2*i + 1
  # 如果 2*i + 1 > n，它无右子节点
 * 一棵有n个节点的完全二叉树，从上到下，从左到右，对节点从 0 开始编号，那么对任意第i个节点：
   # 如果 i = 0，它是根节点
   # 如果 i > 0，它的父节点编号为 floor( (i-1)/2 )
   # 如果 2*i + 1 <= n - 1，它的左子节点编号为 2*i + 1
   # 如果 2*i + 1 > n - 1，它无左子节点
   # 如果 2*i + 2 <= n - 1，它的右子节点编号为 2*i + 2
   # 如果 2*i + 2 > n - 1，它无右子节点

floor(x)：向下取整，无论x是否有小数位，都只取x的整数部分；编程中，除法运算默认就是向下取整，即 5/2 = floor(5/2) = 2
ceiling(x)：向上取整，若x无小数位，则取x的整数部分；若x有小数位，则取整数部分，并+1
例：floor(6) = 6 ; floor(6.6) = 6
   ceiling(6) = 6 ; ceiling(6.3) = 7

面试题：如果一颗完全二叉树有768个节点，求叶子节点的个数
解：n = n0 + n1 + n2，n0 = n2 + 1
   所以，n = 2*n0 + n1 - 1
   由于完全二叉树的n1，要么为0，要么为1
   因此，n1 = 1 时，n = 2*n0，即 n必然是偶数
        叶子节点个数 n0 = n/2，非叶子节点个数 n1+n2 = n/2
        n1 = 0 时，n = 2*n0 - 1 ,即 n必然是奇数
        叶子节点个数 n0 = (n+1)/2，非叶子节点个数 n1+n2 = (n-1)/2
   总结，叶子节点个数 n0 = floor( (n+1)/2 ) = ceiling( n/2 )
        非叶子节点个数 n1+n2 = floor( n/2 ) = ceiling( (n-1)/2 )
   因此叶子节点个数为384

练习：144、二叉树的前序遍历（递归+迭代）
     94、二叉树的中序遍历（递归+迭代）
     145、二叉树的后序遍历（递归+迭代）
     102、二叉树的层序遍历（迭代）
     104、二叉树的最大深度（递归+迭代）

     226、翻转二叉树
     107、二叉树的层序遍历II
     662、二叉树最大宽度

     589、N叉数的前序遍历
     590、N叉数的后序遍历
     559、N叉数的最大深度

     114、二叉树展开为链表
     105、从前序与中序遍历序列构造二叉树
     106、从中序与后序遍历序列构造二叉树
     889、根据前序和后序遍历构造二叉树
     101、对称二叉树