1、比较的逻辑实现：
 * BinarySearchTree有compare(E e1,E e2)方法进行比较，具体的实现，要看构造函数中是否传入了比较器
   如果传入了比较器java.util.Comparator，那么可以自定义不同的比较逻辑，在测试代码中新建一个类或匿名内部类实现接口Comparator的 int compare(T e1. T e2)即可
   如果未传入比较器，那么就要求BinarySearchTree类中存放的数据类型E，必须实现java.lang.Comparable接口，即如果E为User，那么User类中必须实现Comparale接口，并重写int compareTo(T e2)方法，注意此时就只有一种比较逻辑了
   compare(T e1 , T e2)：返回值>0 ，说明e1>e2；返回值=0 ，说明e1=e2；返回值<0，说明e1<e2
   e1.compareTo(T e2)：返回值>0 ，说明e1>e2；返回值=0 ，说明e1=e2；返回值<0，说明e1<e2
 * 对于基本数据类型的包装类，如Integer，都实现了Comparable<Integer>，重写了compareTo(E e)方法，因此我们直接使用即可

2、前序遍历：根节点，左子树，右子树
   中序遍历：左子树，根节点，右子树
   后序遍历：左子树，右子树，根节点
   中序遍历：从上往下，从左往右，进行遍历（利用队列）
3、在遍历中，传入接口，对外界开放权利，允许遍历时对节点进行自定义操作，即重写接口Visitor的void visit(E)方法
4、增强二叉搜索树遍历：将接口改为抽象类，在抽象类中增加成员变量stop，将visit()方法返回值改为boolean；
                   stop线程私有，将visit(E)的返回值赋给stop，stop=true，则停止遍历；stop=false，则继续遍历
5、遍历的应用：
 * 前序遍历：树状结构展示（注意左右子树顺序）
 * 中序遍历：二叉搜索树的中序遍历按升序/降序处理
 * 后序遍历：适用于一些先子后父的操作

6、利用递归和迭代的方式，获取二叉树的高度

7、判断是否为完全二叉树 boolean isComplete()：利用队列，遍历方式选择层序遍历

8、小技巧：看到一棵树，可以选择用层序遍历的方式取出节点值，形成数组，之后用这个数组在代码中进行赋值

练习：144、二叉树的前序遍历（递归+迭代）
     94、二叉树的中序遍历（递归+迭代）
     145、二叉树的后序遍历（递归+迭代）
     102、二叉树的层序遍历（迭代）
     104、二叉树的最大深度（递归+迭代）

     226、翻转二叉树
     107、二叉树的层序遍历II
     662、二叉树最大宽度

     589、N叉数的前序遍历
     590、N叉数的后序遍历
     559、N叉数的最大深度

9、已知【前序遍历+中序遍历】结果，可以推导出唯一一棵二叉树；
   已知【后序遍历+中序遍历】结果，可以推导出唯一一棵二叉树；
   已知【前序遍历+后序遍历】结果，如果这是一棵真二叉树，那么可以推导出唯一一棵二叉树；如果不是，那么结果不唯一；
   推导的条件：已知根节点，并且可以区分左右子树；

10、前驱节点：中序遍历时的前一个节点；
            如果是二叉搜索树，那么前驱节点就是前一个比它小的节点；
    a、if(node.left != null)
       predecessor = node.left.right.right.right......
       终止条件：right == null
    b、if(node.left == null && node.parent != null)
       predecessor = node.parent.parent.parent......
       终止条件：node在parant的 右子树 中，此时的parent为前驱节点；如果到最后都不在parent的右子树中，那么没有前驱节点（例如中序遍历的第一个节点）
    c、if(node.left == null && node.parent == null)
       那么没有前驱节点（例如没有左子树的根节点）
11、后继节点：中序遍历时的后一个节点；
            如果是二叉搜索树，那么后继结点就是后一个比它大的节点；
    a、if(node.right != null)
       predecessor = node.right.left.left.left......
       终止条件：left == null
    b、if(node.right == null && node.parent != null)
       predecessor = node.parent.parent.parent......
       终止条件：node在parent的 左子树 中，此时的parent为后继节点；如果到最后都不在parent的左子树中，那么没有后继节点（例如中序遍历的最后一个节点）
    c、if(node.right == null && node.parent == null)
       那么没有后继节点（例如没有右子树的根节点）


