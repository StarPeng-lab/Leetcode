1、比较的逻辑实现：
 * BinarySearchTree有compare(E e1,E e2)方法进行比较，具体的实现，要看构造函数中是否传入了比较器
   如果传入了比较器java.util.Comparator，那么可以自定义不同的比较逻辑，在测试代码中新建一个类或匿名内部类实现接口Comparator的 int compare(T e1. T e2)即可
   如果未传入比较器，那么就要求BinarySearchTree类中存放的数据类型E，必须实现java.lang.Comparable接口，即如果E为User，那么User类中必须实现Comparale接口，并重写int compareTo(T e2)方法，注意此时就只有一种比较逻辑了
   compare(T e1 , T e2)：返回值>0 ，说明e1>e2；返回值=0 ，说明e1=e2；返回值<0，说明e1<e2
   e1.compareTo(T e2)：返回值>0 ，说明e1>e2；返回值=0 ，说明e1=e2；返回值<0，说明e1<e2
 * 对于基本数据类型的包装类，如Integer，都实现了Comparable<Integer>，重写了compareTo(E e)方法，因此我们直接使用即可

2、前序遍历：根节点，左子树，右子树
   中序遍历：左子树，根节点，右子树
   后序遍历：左子树，右子树，根节点
   中序遍历：从上往下，从左往右，进行遍历（利用队列）
3、在遍历中，传入接口，对外界开放权利，允许遍历时对节点进行自定义操作，即重写接口Visitor的void visit(E)方法
4、增强二叉搜索树遍历：将接口改为抽象类，在抽象类中增加成员变量stop，将visit()方法返回值改为boolean；
                   stop线程私有，将visit(E)的返回值赋给stop，stop=true，则停止遍历；stop=false，则继续遍历
5、遍历的应用：
 * 前序遍历：树状结构展示（注意左右子树顺序）
 * 中序遍历：二叉搜索树的中序遍历按升序/降序处理
 * 后序遍历：适用于一些先子后父的操作

6、利用递归和迭代的方式，获取二叉树的高度

7、判断是否为完全二叉树 boolean isComplete()：利用队列，遍历方式选择层序遍历

8、小技巧：看到一棵树，可以选择用层序遍历的方式取出节点值，形成数组，之后用这个数组在代码中进行赋值

练习：226、翻转二叉树